# Low-Level Design: Role-Based Access Control (RBAC) System

## Table of Contents
- [Overview](#overview)
- [Authentication Process](#authentication-process)
- [Authorization Mechanism](#authorization-mechanism)
- [Token-Based Authentication](#token-based-authentication)
- [Implementation in Java](#implementation-in-java)
- [Performance and Security Considerations](#performance-and-security-considerations)
- [Common Pitfalls and How to Avoid Them](#common-pitfalls-and-how-to-avoid-them)
- [Best Practices for Implementation & Maintenance](#best-practices-for-implementation--maintenance)
- [How to Discuss This in an Interview](#how-to-discuss-this-in-an-interview)

## Overview
Role-Based Access Control (RBAC) is a security model where user permissions are organized into roles. Users are assigned roles, and each role bundles a set of permissions. This simplifies administration by letting you manage permissions at the role level, then assigning roles to users. Common aspects include:

- **User**: Represents an individual, storing attributes like ID and username. Each user can have multiple roles.
- **Role**: Represents a job function or grouping of privileges. A role holds a set of permissions (e.g., "Admin" role has create/delete permissions).
- **Permission**: Represents an allowed action (e.g., `READ_REPORT`, `DELETE_USER`). Roles contain permissions, and users inherit permissions from their roles.

By grouping permissions into roles, RBAC ensures the principle of least privilege and makes it simpler to revoke or grant permissions by assigning/removing roles.

## Authentication Process
Authentication verifies the user’s identity. Typically:

1. **User Login Request**: User submits credentials (username/password).
2. **Credential Verification**: System checks the hashed password in storage against the user’s input (also hashed).
3. **Post-Verification**: If valid, the user is authenticated. The system either creates a server session or issues a token (e.g., JWT) to remember the user on subsequent requests.

Passwords should be securely stored (salted and hashed) using algorithms like BCrypt, Argon2, or PBKDF2, never stored in plaintext. After verifying credentials, the server returns a session identifier or a signed token to the client.

## Authorization Mechanism
Authorization determines what an authenticated user can do. In RBAC, authorization checks revolve around roles and permissions:

```java
boolean checkPermission(User user, Permission permNeeded) {
    for (Role role : user.getRoles()) {
        if (role.getPermissions().contains(permNeeded)) {
            return true;  // user is allowed
        }
    }
    return false; // not allowed
}
```

When a user tries an action like "DELETE_RECORD," the system checks if the user’s roles contain the relevant permission. If yes, access is granted; otherwise, access is denied. This logic might be implemented in code directly or via a framework like Spring Security.

## Token-Based Authentication
Many modern RBAC systems use tokens to maintain user sessions in a stateless manner. A popular approach is JSON Web Tokens (JWTs). A JWT contains:

- **Header**: Metadata (type, signing algorithm).
- **Payload**: Claims about the user (e.g., subject, roles, expiration time).
- **Signature**: Generated by signing header + payload with a secret key or private key.

A server issuing JWTs will validate the signature and claims (like `exp` for expiration) on every request. Short-lived tokens reduce risk if stolen. Systems often use refresh tokens for seamless re-authentication without forcing users to log in repeatedly.

## Implementation in Java
### Core Classes
- **User**: Holds `username`, `passwordHash`, and a set of `Role`s.  
- **Role**: Has a `name` (e.g., "ADMIN") and a set of `Permission`s.  
- **Permission**: Represents an atomic permission (e.g., "DELETE_USER").

These can map to tables in a relational DB: `Users`, `Roles`, `Permissions`, plus join tables like `User_Roles` and `Role_Permissions`.

### Authentication Service Example
```java
public class AuthService {
    @Autowired UserRepository userRepo;

    public String login(String username, String password) throws AuthException {
        User user = userRepo.findByUsername(username);
        if (user == null) {
            throw new AuthException("User not found");
        }
        if (!BCrypt.checkpw(password, user.getPasswordHash())) {
            throw new AuthException("Invalid credentials");
        }
        String token = JwtUtil.generateToken(user);
        return token;
    }

    public User register(String username, String rawPassword, Role initialRole) {
        String hash = BCrypt.hashpw(rawPassword, BCrypt.gensalt());
        User newUser = new User(username, hash);
        newUser.addRole(initialRole);
        userRepo.save(newUser);
        return newUser;
    }
}
```

Here, `JwtUtil.generateToken(user)` would issue a JWT containing user info (e.g., subject = username, role claims, and an expiration).

### Using Spring Security
With Spring Security, you can configure HTTP security to restrict URLs by roles:
```java
@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.csrf().disable()
            .authorizeRequests()
            .antMatchers("/admin/**").hasRole("ADMIN")
            .antMatchers("/manager/**").hasAnyRole("MANAGER", "ADMIN")
            .anyRequest().authenticated()
            .and().sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            .and().addFilter(new JwtAuthenticationFilter());
    }
}
```
This enforces role checks on specific routes. A custom filter parses/validates JWTs and sets the user’s authentication context.

## Performance and Security Considerations
- **Caching Roles/Permissions**: Avoid repeated DB lookups by caching user role/permission data.
- **Database Indexing**: Index user-role and role-permission join tables for faster queries.
- **Token Size**: Keep JWT payload minimal to reduce overhead.
- **Principle of Least Privilege**: Grant only necessary permissions in each role.
- **Secure Password Handling**: Always use salted hashes like BCrypt.
- **Token Expiry & Revocation**: Set JWT expirations. Use refresh tokens or a blacklist to revoke tokens early.
- **Auditing**: Log admin actions, permission changes, and suspicious access attempts.

## Common Pitfalls and How to Avoid Them
- **Storing Plaintext Passwords**: Always store salted, hashed passwords with a strong algorithm.
- **Not Enforcing Token Expiration**: Leads to indefinite validity of stolen tokens. Always set `exp`.
- **Role Explosion**: Too many fine-grained roles hamper maintainability. Consolidate or use role hierarchies.
- **Hardcoding Roles/Permissions**: Better to centralize role/permission data or load them from configuration/DB.
- **Ignoring Logout/Revocation**: Provide a way to invalidate tokens or sessions immediately upon logout.

## Best Practices for Implementation & Maintenance
- **Strong Password Hashing**: Use algorithms like BCrypt or Argon2 with an appropriate cost factor.
- **JWT Security Hygiene**: Use strong secrets, short token lifetimes, and only store minimal data in JWTs.
- **Manage Roles and Permissions via UI**: Provide a dedicated interface for admins to avoid manual DB edits.
- **Follow Least Privilege**: Default new users to minimal roles, removing unneeded permissions as systems evolve.
- **Auditing & Logging**: Log login attempts, role changes, and unauthorized access attempts for security and compliance.
- **Use Frameworks**: Spring Security or Apache Shiro handle many RBAC and security tasks out of the box.

## How to Discuss This in an Interview
1. **Clarify Authentication vs Authorization**: Explain user login (password hashing) vs. permission checks (roles/permissions).
2. **Walk Through a Login Flow**: Emphasize secure password storage and how the system creates tokens or sessions.
3. **Describe RBAC**: Detail how roles map to permissions, and how a user’s role membership grants (or denies) specific actions.
4. **Talk JWT vs Session**: Outline the trade-offs between stateless tokens (revocation challenges) vs. stateful sessions.
5. **Mention Security Best Practices**: Salting and hashing passwords, using HTTPS, implementing token expiration and revocation.
6. **Scaling and Maintenance**: Address caching, auditing, role explosion, and performance concerns.
7. **Give Concrete Code/Framework Examples**: Show experience with Spring Security or similar, demonstrating role checks on endpoints.
8. **Stay Organized**: Present the design steps and highlight potential pitfalls and how to avoid them.
